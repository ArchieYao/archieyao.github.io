---
layout: post
title:  "Redis作为消息队列的用法"
date:   2020-03-1 11:18:23 +0700
categories: [Redis,Java]
tags:   Redis Java
comments: true
---

摘要：Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。

Redis 与其他 key - value 缓存产品有以下三个特点：

* Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
* Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
* Redis支持数据的备份，即master-slave模式的数据备份。

[MORE INFO](https://www.runoob.com/redis/redis-intro.html).

------

## Redis  发布订阅(pub/sub)

订阅消息：

![client-channel]({{ "/assets/img/sample/client-channel.png" | relative_url }})


发布订阅模式本质上还是生产者-消费者模型，客户端订阅channel，可以多个客户端同时定义同一个channel。


发布消息：

![publish-message]({{ "/assets/img/sample/publish-message.png" | relative_url }})

生产者发送消息给channel，redis会将消息推送给每一个订阅channel的client。从客户端角度来说，这是属于 “推” 的模式。


### 相关命令

| 序号 | 命令及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | [PSUBSCRIBE pattern [pattern ...]] 订阅一个或多个符合给定模式的频道。 |
| 2    | [PUBSUB subcommand argument [argument ...]  查看订阅与发布系统状态。 |
| 3    | [PUBLISH channel message] 将信息发送到指定的频道。           |
| 4    | [PUNSUBSCRIBE [pattern pattern ...]] 退订所有给定模式的频道。 |
| 5    | [SUBSCRIBE channel [channel ...]] 订阅给定的一个或多个频道的信息。 |
| 6    | [UNSUBSCRIBE [channel [channel ...]]]  指退订给定的频道。    |


### SpringBoot集成 pub/sub 

导入相关依赖：

```xml

 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter</artifactId>
 </dependency>

 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-data-redis</artifactId>
 </dependency>

 <dependency>
     <groupId>com.fasterxml.jackson.core</groupId>
     <artifactId>jackson-databind</artifactId>
     <version>2.8.10</version>
 </dependency>
```


然后新建一个config类配置相关参数：


```java

    /**
     * redis消息监听器容器
     * 可以添加多个监听不同话题的redis监听器，只需要把消息监听器和相应的消息订阅处理器绑定，该消息监听器
     * 通过反射技术调用消息订阅处理器的相关方法进行一些业务处理
     * @param connectionFactory
     * @param listenerAdapter
     * @return
     */
    @Bean
    RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,
                                            MessageListenerAdapter listenerAdapter
    ) {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        //可以添加多个 messageListener
        container.addMessageListener(listenerAdapter, new PatternTopic("redis*"));
        return container;
    }

    /**
     * 消息监听器适配器，绑定消息处理器，利用反射技术调用消息处理器的业务方法
     * @param redisReceiver
     * @return
     */
    @Bean
    MessageListenerAdapter listenerAdapter(RedisReceiver redisReceiver) {
        return new MessageListenerAdapter(redisReceiver, "receiveMessage");
    }

    /**
     *RedisTemplate配置类
     */
    @Bean
    @SuppressWarnings("all")
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = 
            new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        // key采用String的序列化方式
        template.setKeySerializer(stringRedisSerializer);
        // hash的key也采用String的序列化方式
        template.setHashKeySerializer(stringRedisSerializer);
        // value序列化方式采用jackson
        template.setValueSerializer(jackson2JsonRedisSerializer);
        // hash的value序列化方式采用jackson
        template.setHashValueSerializer(jackson2JsonRedisSerializer);
        template.afterPropertiesSet();
        return template;
    }
```

```container(...)``` 主要配置channel相关信息，这里是在配置中订阅哪些channel，可以添加多个，并支持通配符。


```listenerAdapter(...)``` 主要配置消费端，这里定义了消费端必须是```RedisReceiver```类的```receiveMessage```方法。 因此需要定义一个消费端的类。


``` java

/**
 * @author YaoQi
 * Date: 2020/2/26 20:45
 * Description:
 */
@Service
public class RedisReceiver {

    public void receiveMessage(String message) {
        //这里是收到通道的消息之后执行的方法
        System.out.println("消息来了：" + message);
        try {
            Thread.sleep(1000 * 2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(message + "finished");
    }
}
```

```redisTemplate``` 与sub/pub无关.


发送消息调用的方法：

``` java

    /**
     * 向指定channel中发送消息
     *
     * @param channel
     * @param message
     */
    public void send(String channel, String message) {
        redisTemplate.convertAndSend(channel, message);
    }
```

通过这种pub/sub的用法，可以得出几个结论：
1、这种生产-消费并不灵活，并不能动态地生成一些channel，channel信息需要在程序initial时确定。
2、消费端并不自由，不能主动拉取，也就是poll的模式。
3、可靠性远不如kafka。

## 借助Redis 重新实现消息队列

上述中这种模型貌似用在聊天、订阅、分发中比较常见，怎么样redis更“消息队列”一些呢？

redis中有种队列的结构，是一种双向队列，这样能保证消息的有序性，同时消费完成能移除队首元素，类型于kafka的commit。基于这种特性，完全可以用作小批量、快速、高效的消息队列。

![redis-queue]({{ "/assets/img/sample/redis-queue.png" | relative_url }})


### 相关API


``` java

public interface ListOperations<K, V> {
    List<V> range(K var1, long var2, long var4); // 从指定下标读取
    void trim(K var1, long var2, long var4); // 裁剪，获取指定区间的值
    Long size(K var1);	// 获取队列大小
    Long leftPush(K var1, V var2); // 从左侧push
    Long leftPushAll(K var1, V... var2); // 从左侧批量push
    Long leftPushAll(K var1, Collection<V> var2);  // 从左侧批量push
    Long leftPushIfPresent(K var1, V var2); // 从左侧批量push，前提是key存在
    Long leftPush(K var1, V var2, V var3); //在列表的元素前或者后插入元素,var2 BEFORE|AFTER
    Long rightPush(K var1, V var2);  // 从右侧push
    Long rightPushAll(K var1, V... var2); // 从右侧批量push
    Long rightPushAll(K var1, Collection<V> var2); // 从右侧批量push
    Long rightPushIfPresent(K var1, V var2); // 从右侧批量push，前提是key存在
    Long rightPush(K var1, V var2, V var3); // 在列表的元素前或者后插入元素，var2 BEFORE|AFTER
    void set(K var1, long var2, V var4); 
    Long remove(K var1, long var2, Object var4); // 移除元素，var2为count
    V index(K var1, long var2); // 通过下标获取元素
    V leftPop(K var1); // 从左侧pop元素
    V leftPop(K var1, long var2, TimeUnit var4); // 从左侧pop元素，并有超时时间
    V rightPop(K var1); // 从右侧pop元素
    V rightPop(K var1, long var2, TimeUnit var4); // 从右侧pop，并有超时时间
    V rightPopAndLeftPush(K var1, K var2); // 从右侧pop，并从左侧push
    // 从右侧pop，并从左侧push
    V rightPopAndLeftPush(K var1, K var2, long var3, TimeUnit var5); 
```


### tips

pop会将元素从队列中移除，并return。但API提供的pop只能返回一个元素，或者在指定时间内返回一批元素。

并没有移除指定元素个数的方法。可通过```index()``` 和```remove()```方法的组合实现这样的功能。

以这种模型实现消息队列，需在消费端主动poll，主动拉取元素消费。

------


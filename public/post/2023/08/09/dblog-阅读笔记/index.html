<!DOCTYPE html>
<html lang="cn-zh">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title> DBLog 阅读笔记 | 大道至简</title>
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils/css/article.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils/css/heading-anchor.min.css">
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="/css/custom.css" />
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PGMJFXZJRT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PGMJFXZJRT');
</script>
  </head>

  <body>

    <nav class="menu">
    <ul>
      <li class="left">
        <a href="/"><span>大道至简</span></a>
      </li>
      
      <li>
        <a href="/post/">Posts</a>
      </li>
      
      <li>
        <a href="/tags/">Tags</a>
      </li>
      
      <li id="menu-search">
        <a href="/#">Search</a>
      </li>
      
    </ul>
    </nav>


<div class="container single">
<main>

<div class="article-meta">
<h1><span class="title">DBLog 阅读笔记</span></h1>

<h3 class="date">2023-08-09</h3>
<p class="terms">
  
  
  
  
  Tags: <a href="/tags/algorithm">Algorithm</a> <a href="/tags/paper">Paper</a> <a href="/tags/dblog">DBLog</a> 
  
  
</p>
</div>

<div class="article">
<h2 id="介绍">介绍</h2>
<p>论文原名: <code>DBLog: A Watermark Based Change-Data-Capture Framework</code> , 基于 <code>Watermark</code> 的 <code>Change-Data-Capture</code>(数据库实时捕获已提交的变更记录) 框架, 本质上是解决数据库同步(全量+增量)的框架, <code>Watermark</code> 是框架使用的一种手段, 在源表中创建表,生成唯一 uuid 并更新表数据, 在源表中就会生成一条变更记录,记作 <code>Watermark</code> 的变更记录, 通过 <code>High Watermark</code> 和 <code>Low Watermark </code> 将变更记录分割, 保证 select chunk 数据包含了增量的变更记录.</p>
<p>框架整体架构如下:</p>
<p><img src="/assets/img/DBLog-1.svg" alt="DBLog-1"></p>
<p>框架特点:</p>
<ul>
<li>按顺序处理捕获到的 <code>changelog</code>;</li>
<li>转储可以随时进行，跨所有表，针对一个特定的表或者针对一个表的具体主键;</li>
<li>以块(chunk)的形式获取转储，日志与转储事件交错。通过这种方式，<code>changelog</code> 可以与转储处理一起进行。如果进程终止，它可以在最后一个完成的块之后恢复，而不需要从头开始。这还允许在需要时对转储进行调整和暂停;</li>
<li>不会获取表级锁，这可以防止影响源数据库上的写流量;</li>
<li>支持任何类型的输出，因此，输出可以是流、数据存储甚或是 API;</li>
<li>设计充分考虑了高可用性。因此，下游的消费者可以放心，只要源端发生变化，它们就可以收到变化事件。</li>
</ul>
<p>注意, 本文并非详细介绍 <code>DBLog</code> 框架本身, 而是分析其框架背后的设计思路.</p>
<h2 id="算法流程">算法流程</h2>
<h3 id="chunk-划分">chunk 划分</h3>
<p>对于源表数据, 全量数据使用分块读取, 基于 <code>primary key</code> 顺序排序, 将全量数据划分为 N 个 chunk;</p>
<p><img src="/assets/img/DBLog-2.svg" alt="DBLog-2"></p>
<h3 id="watermark">watermark</h3>
<p>基于 chunk 划分, 然后 chunk 数据全量写入下游之后, 再将源表的变更记录 <code>changelog</code> 增量同步到下游, 整体思路就是这样, 但是划分 chunk 有个问题需要解决, 就是先同步到下游的数据不一定的最终的数据, 例如上图 chunk1 中的数据在同步到下游之后可能会删除, 那chunk1 的数据写到下游之后, 下游就会出现脏数据; 如何解决 chunk 和 <code>changelog</code> 之间不会相互覆盖的问题?</p>
<p>为了解决这一问题, DBLog 的解决办法是引入 <code>watermark</code> 的机制, 在查询 chunk 期间, 对 <code>changelog</code> 进行标记 , 然后去移除 select chunk 期间, chunk 数据中对应的 <code>changelog</code> 数据, 这样就解决了 select chunk 数据和期间对应的 <code>changelog</code> 数据的顺序问题 , 这也就是论文的精妙之处!</p>
<p><code>watermark</code> 是通过源数据库中的一个表实现的, 表存储在专用的命名空间中，因此不会与应用程序表发生冲突。改表只包含一行,存储 <code>UUID</code> 字段; 通过将这一行更新为特定的 <code>UUID</code> 来生成<code>watermark</code>, 行更新生成一个更改事件。</p>
<h4 id="算法伪码">算法伪码</h4>
<p>算法伪代码如下:</p>
<pre><code class="language-go">// step1 暂停处理 changelog
pause log event processing 
lw := uuid() 
hw := uuid()
// step2 通过更新watermark表生成 low watermark
update watermark table set value = lw
// step3 为下一个块运行 SELECT 语句，并将结果集存储在内存中，按主键索引
chunk := select next chunk from table
// step4 通过更新watermark表生成 high watermark
update watermark table set value = hw
// step5 恢复处理 changelog, 监听 high watermark 
resume log event processing
inwindow := false
// other steps of event prosessing loop
while true do 
    e := next event from changelog
  if not inwindow then{
     if e is not watermark then
        append e to outputbuffer
     else if e is watermark with value lw then
       inwindow := true
  }else{
     if e is not watermark then{
      // step 6 接收到lw事件后，开始从结果集中删除所有在lw之后接收到的changelog主键的条目
       if chunk contains e.key then{
        remove e.key from chunk
       }
       append e to outputbuffer
     }else if e is watermark with value hw then {
      // step7 接收到hw事件后，将所有剩余的结果集条目发送到输出
      for each row in chunk do{
        append row to outputbuffer
      }
    }
  }

</code></pre>
<h4 id="算法步骤分析">算法步骤分析</h4>
<p>示例表，k1 到 k6 为主键。每个更改日志条目表示主键的创建、更新或删除事件。在下图展示了<code>watermark</code>的生成和chunk的选择（step 1 到 step 4）。重点看从位于<code>watermark</code>之间的主键结果: 删除选定chunk的行（step 5 到 step 7）。</p>
<p><img src="/assets/img/DBLog-3.svg" alt="DBLog-3"></p>
<p><img src="/assets/img/DBLog-4.svg" alt="DBLog-4"></p>
<p>如果一个或多个事务在 <code>lw</code> 和 <code>hw</code> 之间提交了大量的行更改，则可能会出现大量的 <code>changelog</code>。这就是为什么论文在 step 2-4 期间会短暂地暂停日志处理，从而保证不会遗漏<code>watermark</code>, 这样<code>changelog</code>处理就可以在以后逐个事件地恢复。日志处理暂停的时间很短，因为 step 2-4 预计会比较快：水印更新是单个的写操作，而 <code>SELECT</code> 操作有一定的范围, 可能耗时较长。</p>
<p>在第 7 步接收到<code>hw</code>后，非冲突的chunk块将被提交写入，以便按顺序发送到下游。这是一个非阻塞操作，因为写入在单独的线程中运行，允许在step 7 之后快速恢复日志处理。然后，<code>changelog</code>处理将继续处理<code>hw</code>之后发生的事件。</p>
<p>在下图中，使用上图相同的示例来描述整个同步数据的写顺序, 出现在<code>hw</code>之前的<code>changelog</code>首先被写入, 然后是chunk结果(被修正后), 最后是在<code>hw</code>之后发生的<code>changelog</code>。</p>
<p><img src="/assets/img/DBLog-5.svg" alt="DBLog-5"></p>
<h2 id="参考">参考</h2>
<p><a href="https://arxiv.org/pdf/2010.12597.pdf">https://arxiv.org/pdf/2010.12597.pdf</a></p>
<p><a href="https://netflixtechblog.com/dblog-a-generic-change-data-capture-framework-69351fb9099b">https://netflixtechblog.com/dblog-a-generic-change-data-capture-framework-69351fb9099b</a></p>

</div>
</main>

<section class="appendix">





<div>
  <div class="side side-left"><h3>重复使用</h3></div>
  Text and figures are licensed under <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution CC BY 4.0</a>. The source code is licensed under MIT. The full source is available at <a href="https://github.com/qiref/qiref.github.io">https://github.com/qiref/qiref.github.io</a>.
</div>



<div>
  <div class="side side-left"><h3>欢迎修订</h3></div>
  
  
  
    
    
  
  如果您发现本文里含有任何错误（包括错别字和标点符号），欢迎<a href="https://github.com/qiref/qiref.github.io/tree/master/content/post/2023-08-09-DBLog%20%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0.md" id="edit-link">在本站的 GitHub 项目里提交修订意见。</a>
</div>




</section>



<nav class="post-nav">
  <span class="nav-next">&larr; <a href="/post/2023/06/26/java%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" title=下一篇&#32;(旧)>Java进程分析工具</a></span>
  &hercon;
  <span class="nav-prev"><a href="/post/2023/10/01/skip-lists-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title=上一篇&#32;(新)>Skip Lists 阅读笔记</a> &rarr;</span>
</nav>


<script src="https://utteranc.es/client.js"
        repo="qiref/qiref.github.io"
        issue-term="pathname"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>

</div>


  <footer>
  




  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-PGMJFXZJRT"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-PGMJFXZJRT');
        }
      </script>
    
  




<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/number-sections.min.js,npm/@xiee/utils/js/toc.min.js,npm/@xiee/utils/js/toc-highlight.min.js,npm/@xiee/utils/js/sidenotes.min.js,npm/@xiee/utils/js/right-quote.min.js,npm/@xiee/utils/js/center-img.min.js,npm/@xiee/utils/js/fix-pandoc.min.js,npm/@xiee/utils/js/heading-anchor.min.js" defer></script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/rstudio/markdown/inst/resources/prism-xcode.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>


  <div class="footer">
  
  <ul>
    
    <li class="optional">
      <a href="/post/">Posts</a>
    </li>
    
    <li class="optional">
      <a href="/tags/">Tags</a>
    </li>
    
    <li id="menu-edit">
      <a href="#">Suggest an edit</a>
    </li>
    
    <li>
      <a href="#">Back to top</a>
    </li>
    
  </ul>
  </div>
  
  </footer>
  <script src="/js/features.js" defer></script>
  </body>
</html>

